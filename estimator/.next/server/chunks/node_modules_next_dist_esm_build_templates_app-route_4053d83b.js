module.exports=[37939,e=>{"use strict";var t=e.i(47909),a=e.i(74017),r=e.i(96250),n=e.i(59756),s=e.i(61916),i=e.i(14444),o=e.i(37092),c=e.i(69741),l=e.i(16795),p=e.i(87718),d=e.i(95169),u=e.i(47587),h=e.i(66012),m=e.i(70101),g=e.i(26937),f=e.i(10372),R=e.i(93695);e.i(52474);var S=e.i(5232),E=e.i(89171),y=e.i(6294);async function A(e,t){let a="";t&&Object.values(t).some(e=>e&&e.length>0)&&(a=`

USER'S PREFERRED TECH STACK:
IMPORTANT: The user has specified their preferred technologies. Use these as defaults whenever appropriate:
${t.frontend&&t.frontend.length>0?`- Frontend: ${t.frontend.join(", ")}`:""}
${t.backend&&t.backend.length>0?`- Backend: ${t.backend.join(", ")}`:""}
${t.database&&t.database.length>0?`- Database: ${t.database.join(", ")}`:""}
${t.auth&&t.auth.length>0?`- Auth: ${t.auth.join(", ")}`:""}
${t.infrastructure&&t.infrastructure.length>0?`- Infrastructure: ${t.infrastructure.join(", ")}`:""}
${t.payment_apis&&t.payment_apis.length>0?`- Payment APIs: ${t.payment_apis.join(", ")}`:""}
${t.ai_apis&&t.ai_apis.length>0?`- AI APIs: ${t.ai_apis.join(", ")}`:""}
${t.services&&t.services.length>0?`- Services: ${t.services.join(", ")}`:""}

Use these preferred technologies in your recommendations unless the project specifically requires different tools.
`);let r=`You are an expert software development consultant who creates feature-focused, actionable blueprints for modern applications.

CRITICAL: Return ONLY valid JSON. No markdown, no code blocks, no explanatory text. Just the raw JSON object.${a}

IMPORTANT NAMING GUIDELINES:
- Create a CREATIVE, BRANDABLE app name (like "TasteTrail", "Snapify", "Chatly")
- NOT descriptive names (avoid "Personal Restaurant Journal", "Chat Application")
- Think like a real app in the App Store - catchy, memorable, unique
- Maximum 2 words, easy to say and remember

SUMMARY GUIDELINES:
- Focus on WHAT USERS CAN DO, not technical implementation
- Highlight the core value proposition and main capabilities
- Keep it concise (2-3 sentences max)
- Example: "TasteTrail lets food lovers discover, save, and share restaurant experiences. Users can log meals with photos, get AI-powered recommendations, and connect with fellow foodies."
- NOT: "A full-stack application built with Next.js that provides restaurant tracking functionality using PostgreSQL database."

IMPORTANT: Always recommend the MOST MODERN and CUTTING-EDGE technologies available in 2025:

Tech Stack Preferences:
- Frontend: Next.js 15+, React 19, TypeScript, Tailwind CSS v4
- Backend API:
  * Simple APIs: Next.js API Routes
  * Type-safe APIs: tRPC (highly recommended for full-stack Next.js)
  * High-performance/Edge: Hono (ultra-fast, edge-ready)
  * AVOID: Express, Fastify (outdated for modern apps)
- Database: PostgreSQL, MySQL (actual database engines - NOT services like Supabase)
- ORM: Prisma, Drizzle ORM (database tools)
- Auth: Clerk, Supabase Auth, Auth.js/NextAuth
- Services: Resend (email), Stripe (payments), Uploadthing (storage)
- Infrastructure: Vercel, Railway, Fly.io (hosting platforms)
- Mobile: React Native with Expo, or native Swift/Kotlin

BACKEND SELECTION GUIDE:
- For simple CRUD with Next.js: Next.js API Routes
- For type-safe full-stack: tRPC (best choice for most apps)
- For edge/serverless performance: Hono
- Consider suggesting multiple: ["tRPC", "Hono"] for flexibility

IMPORTANT CATEGORIZATION:
- "frontend": UI frameworks only (React, Next.js, TypeScript, Tailwind)
- "backend": API frameworks only (Next.js API Routes, tRPC, Hono)
- "database": Actual database + ORM (PostgreSQL, Prisma ORM)
- "auth": Authentication services (Clerk, Supabase Auth, Auth.js)
- "services": Third-party services (Resend, Stripe, Uploadthing, etc.)
- "infrastructure": Hosting/deployment (Vercel, Railway, Supabase platform)

Your response must be a valid JSON object with this exact structure:
{
  "projectName": "Suggested project name",
  "summary": "2-3 sentence FEATURE-FOCUSED summary highlighting the core capabilities users will get",
  "features": [
    {
      "name": "Barcode Scanner Screen",
      "description": "Scanner screen with camera access and barcode detection. Product lookup modal shows item details when barcode is scanned.",
      "tier": "free",
      "tech": {
        "packages": ["react-camera-pro", "quagga2"],
        "services": ["UPC Database API"]
      },
      "resources": []
    },
    {
      "name": "Recipe Discovery Screen",
      "description": "Recipe discovery page with ingredient matching and recipe cards. Detail modal shows cooking instructions and ingredients list.",
      "tier": "pro",
      "tech": {
        "packages": ["openai", "axios"],
        "services": ["OpenAI API", "Spoonacular API"]
      },
      "resources": []
    }
  ],
  "techStack": {
    "frontend": ["Next.js 15", "React 19", "TypeScript", "Tailwind CSS"],
    "backend": ["tRPC", "Hono"],
    "database": ["PostgreSQL", "Prisma ORM"],
    "auth": ["Clerk"],
    "payment_apis": ["Stripe", "PayPal"],
    "ai_apis": ["OpenAI", "Anthropic"],
    "services": ["Resend", "Uploadthing"],
    "infrastructure": ["Vercel"]
  },
  "risks": ["Concise technical risk 1", "Concise technical risk 2"],
  "nextSteps": [
    "Create Next.js project with TypeScript and Tailwind CSS",
    "Set up Clerk for authentication (signup/login)",
    "Design database schema in Prisma (users, posts tables)",
    "Deploy to Vercel and configure environment variables",
    "Implement core feature components",
    "Set up Stripe for payment processing"
  ],
  "questions": [
    "Simple yes/no question?",
    { "text": "Question with specific options?", "options": ["Option 1", "Option 2", "Option 3"] }
  ]
}

NOTE: Backend should typically include tRPC for type safety. Add Hono for edge/performance needs.

IMPORTANT FEATURES STRUCTURE:
- Generate 5-10 USER-FACING features ordered by IMPORTANCE/VALUE
- Order features from most critical to nice-to-have:
  1. CORE features (essential for app to function - e.g., "Barcode Scanning", "Pantry Inventory View")
  2. ESSENTIAL features (important functionality - e.g., "Expiration Tracking", "Search & Filter")
  3. VALUABLE features (strong utility - e.g., "Shopping List Generation", "Low Stock Alerts")
  4. ENHANCEMENT features (nice-to-have - e.g., "Recipe Suggestions", "Meal Planning")
  5. PREMIUM features (advanced/AI - e.g., "Smart Recommendations", "Nutrition Analysis")

FEATURE NAMING:
- Use SPECIFIC screen/view names that describe the main UI element (3-5 words)
- Include "Screen", "Dashboard", "View", "Page" in the name to be specific
- Examples: "Barcode Scanner Screen", "Pantry Dashboard View", "Expiration Tracker Page", "Shopping List Generator", "Recipe Discovery Screen"
- Examples: "Drink Log Screen", "Monthly Stats Dashboard", "Health Insights Page"
- NOT: "Barcode Scanning", "Drink Logging", "User Authentication"

FEATURE DESCRIPTIONS:
- Provide brief, clear implementation summary (1-2 sentences)
- Focus on: what screens/pages are needed and key UI elements
- Keep it simple and readable - avoid overwhelming technical details
- Examples:
  ✅ GOOD: "Scanner screen with camera access and barcode detection. Product lookup modal shows item details when barcode is scanned."
  ✅ GOOD: "Inventory dashboard showing all items with search, filters, and quantity controls. Item detail view for editing."
  ✅ GOOD: "Quick-add screen with drink type selector, serving size options, and ABV calculator. Preset buttons for common drinks."

Each feature should follow this structure:
{
  "name": "Specific Screen/View Name (e.g., Barcode Scanner Screen, Recipe Discovery Screen, Drink Log Screen)",
  "description": "Brief 1-2 sentence summary of what screens/pages are needed and key UI elements. Keep it simple and readable.",
  "tier": "free" OR "pro",
  "tech": {
    "packages": ["Exact npm package names like '@clerk/nextjs', 'uploadthing', 'stripe'"],
    "services": ["Third-party services like 'Clerk', 'Supabase', 'Stripe', 'Vercel'"]
  },
  "resources": []
}

FEATURE TIER GUIDELINES:
- "free": Basic functionality, essential for core experience
- "pro": Advanced features, premium capabilities, heavy API usage

Focus on technical depth - developers need to know EXACTLY what packages/APIs to use.

IMPORTANT FOR NEXT STEPS:
Generate 5-8 PRACTICAL, ACTIONABLE next steps that a developer can immediately execute.
Each step should be a concrete task, not a vague suggestion. Examples:
- "Set up Supabase project and configure authentication"
- "Design database schema with users, posts, and comments tables"
- "Install and configure Clerk for user authentication"
- "Create Next.js project with TypeScript and Tailwind CSS"
- "Set up Stripe account and configure payment webhooks"
- "Deploy to Vercel and configure environment variables"
- "Implement responsive navigation component"
- "Set up tRPC router for type-safe API endpoints"

Focus on SETUP, INFRASTRUCTURE, and CORE IMPLEMENTATION tasks in a logical order.

IMPORTANT FOR QUESTIONS:
- For simple yes/no questions, use strings: "Do you need offline support?"
- For questions with specific choices, use objects with options:
  { "text": "Preferred platform?", "options": ["Mobile", "Web", "Both"] }
- Always provide 2-4 specific options when the answer isn't a simple yes/no
- Keep options SHORT and SIMPLE (e.g., "Mobile", "Web", "Both" not "Mobile first", "Web only", "Both equally important")
- Options should be clear, specific, and mutually exclusive

Focus on providing detailed features, modern tech stack recommendations, identifying potential risks, and practical next steps.`,n=`Project Description: "${e}"

Please analyze this project and provide a comprehensive estimate in JSON format.`;try{let e=await (0,y.callOpenRouter)([{role:"system",content:r},{role:"user",content:n}],{model:y.MODELS.CLAUDE_35_SONNET,temperature:.7,max_tokens:1200}),t=e.trim(),a=(t=t.replace(/```json\s*/g,"").replace(/```\s*/g,"")).match(/\{[\s\S]*\}/);if(!a)throw console.error("Failed to extract JSON. Raw response:",e),console.error("Cleaned response:",t),Error("Failed to extract JSON from AI response");return JSON.parse(a[0])}catch(e){throw console.error("Error generating estimate:",e),Error("Failed to generate project estimate")}}var v=e.i(21783);async function w(e){try{let t,{projectDescription:a}=await e.json();if(!a||"string"!=typeof a)return E.NextResponse.json({error:"Project description is required"},{status:400});if(a.length<20)return E.NextResponse.json({error:"Please provide a more detailed project description (at least 20 characters)"},{status:400});try{let e=await (0,v.createClient)(),{data:{user:a}}=await e.auth.getUser();if(a){let{data:r}=await e.from("profiles").select("tech_preferences").eq("id",a.id).single();r?.tech_preferences&&(t=r.tech_preferences,console.log("Using user tech preferences:",t))}}catch(e){console.log("No user preferences found, using defaults")}let r=await A(a,t);return E.NextResponse.json({estimate:r})}catch(e){return console.error("Error generating estimate:",e),E.NextResponse.json({error:"Failed to generate estimate. Please try again."},{status:500})}}e.s(["POST",()=>w],68692);var T=e.i(68692);let N=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/generate-estimate/route",pathname:"/api/generate-estimate",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/app/api/generate-estimate/route.ts",nextConfigOutput:"",userland:T}),{workAsyncStorage:P,workUnitAsyncStorage:b,serverHooks:C}=N;function I(){return(0,r.patchFetch)({workAsyncStorage:P,workUnitAsyncStorage:b})}async function O(e,t,r){N.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let E="/api/generate-estimate/route";E=E.replace(/\/index$/,"")||"/";let y=await N.prepare(e,t,{srcPage:E,multiZoneDraftMode:!1});if(!y)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:A,params:v,nextConfig:w,parsedUrl:T,isDraftMode:P,prerenderManifest:b,routerServerContext:C,isOnDemandRevalidate:I,revalidateOnlyGenerated:O,resolvedPathname:x,clientReferenceManifest:k,serverActionsManifest:U}=y,D=(0,c.normalizeAppPath)(E),j=!!(b.dynamicRoutes[D]||b.routes[x]),M=async()=>((null==C?void 0:C.render404)?await C.render404(e,t,T,!1):t.end("This page could not be found"),null);if(j&&!P){let e=!!b.routes[x],t=b.dynamicRoutes[D];if(t&&!1===t.fallback&&!e){if(w.experimental.adapterPath)return await M();throw new R.NoFallbackError}}let F=null;!j||N.isDev||P||(F="/index"===(F=x)?"/":F);let L=!0===N.isDev||!j,_=j&&!L;U&&k&&(0,i.setReferenceManifestsSingleton)({page:E,clientReferenceManifest:k,serverActionsManifest:U,serverModuleMap:(0,o.createServerModuleMap)({serverActionsManifest:U})});let H=e.method||"GET",$=(0,s.getTracer)(),q=$.getActiveScopeSpan(),B={params:v,prerenderManifest:b,renderOpts:{experimental:{authInterrupts:!!w.experimental.authInterrupts},cacheComponents:!!w.cacheComponents,supportsDynamicResponse:L,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:w.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,r)=>N.onRequestError(e,t,r,C)},sharedContext:{buildId:A}},G=new l.NodeNextRequest(e),V=new l.NodeNextResponse(t),K=p.NextRequestAdapter.fromNodeNextRequest(G,(0,p.signalFromNodeResponse)(t));try{let i=async e=>N.handle(K,B).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=$.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==d.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let r=a.get("next.route");if(r){let t=`${H} ${r}`;e.setAttributes({"next.route":r,"http.route":r,"next.span_name":t}),e.updateName(t)}else e.updateName(`${H} ${E}`)}),o=!!(0,n.getRequestMeta)(e,"minimalMode"),c=async n=>{var s,c;let l=async({previousCacheEntry:a})=>{try{if(!o&&I&&O&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let s=await i(n);e.fetchMetrics=B.renderOpts.fetchMetrics;let c=B.renderOpts.pendingWaitUntil;c&&r.waitUntil&&(r.waitUntil(c),c=void 0);let l=B.renderOpts.collectedTags;if(!j)return await (0,h.sendResponse)(G,V,s,B.renderOpts.pendingWaitUntil),null;{let e=await s.blob(),t=(0,m.toNodeOutgoingHttpHeaders)(s.headers);l&&(t[f.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==B.renderOpts.collectedRevalidate&&!(B.renderOpts.collectedRevalidate>=f.INFINITE_CACHE)&&B.renderOpts.collectedRevalidate,r=void 0===B.renderOpts.collectedExpire||B.renderOpts.collectedExpire>=f.INFINITE_CACHE?void 0:B.renderOpts.collectedExpire;return{value:{kind:S.CachedRouteKind.APP_ROUTE,status:s.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:r}}}}catch(t){throw(null==a?void 0:a.isStale)&&await N.onRequestError(e,t,{routerKind:"App Router",routePath:E,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:_,isOnDemandRevalidate:I})},C),t}},p=await N.handleResponse({req:e,nextConfig:w,cacheKey:F,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:b,isRoutePPREnabled:!1,isOnDemandRevalidate:I,revalidateOnlyGenerated:O,responseGenerator:l,waitUntil:r.waitUntil,isMinimalMode:o});if(!j)return null;if((null==p||null==(s=p.value)?void 0:s.kind)!==S.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==p||null==(c=p.value)?void 0:c.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});o||t.setHeader("x-nextjs-cache",I?"REVALIDATED":p.isMiss?"MISS":p.isStale?"STALE":"HIT"),P&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let d=(0,m.fromNodeOutgoingHttpHeaders)(p.value.headers);return o&&j||d.delete(f.NEXT_CACHE_TAGS_HEADER),!p.cacheControl||t.getHeader("Cache-Control")||d.get("Cache-Control")||d.set("Cache-Control",(0,g.getCacheControlHeader)(p.cacheControl)),await (0,h.sendResponse)(G,V,new Response(p.value.body,{headers:d,status:p.value.status||200})),null};q?await c(q):await $.withPropagatedContext(e.headers,()=>$.trace(d.BaseServerSpan.handleRequest,{spanName:`${H} ${E}`,kind:s.SpanKind.SERVER,attributes:{"http.method":H,"http.target":e.url}},c))}catch(t){if(t instanceof R.NoFallbackError||await N.onRequestError(e,t,{routerKind:"App Router",routePath:D,routeType:"route",revalidateReason:(0,u.getRevalidateReason)({isStaticGeneration:_,isOnDemandRevalidate:I})}),j)throw t;return await (0,h.sendResponse)(G,V,new Response(null,{status:500})),null}}e.s(["handler",()=>O,"patchFetch",()=>I,"routeModule",()=>N,"serverHooks",()=>C,"workAsyncStorage",()=>P,"workUnitAsyncStorage",()=>b],37939)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_4053d83b.js.map